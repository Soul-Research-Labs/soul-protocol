#!/usr/bin/env node
/**
 * sync-abis.ts — Copy contract ABIs from Foundry build output to SDK.
 *
 * Reads compiled artifacts from `out/` (Foundry) and writes minified ABIs
 * to `sdk/src/abis/`. This prevents ABI drift between contracts and SDK.
 *
 * Usage:
 *   npx ts-node scripts/sync-abis.ts
 *   # or after: npm run build (forge build must complete first)
 *
 * The script:
 *   1. Reads each contract's JSON artifact from out/<Contract>.sol/<Contract>.json
 *   2. Extracts the "abi" field
 *   3. Writes it to sdk/src/abis/<Contract>.ts as a typed const export
 */

import * as fs from "fs";
import * as path from "path";

const PROJECT_ROOT = path.resolve(__dirname, "..");
const OUT_DIR = path.join(PROJECT_ROOT, "out");
const ABI_DIR = path.join(PROJECT_ROOT, "sdk", "src", "abis");

/**
 * Contracts whose ABIs should be synced to the SDK.
 * Maps from the Solidity contract name to the output filename.
 */
const CONTRACTS: Record<string, string> = {
  // Core
  SoulProtocolHub: "SoulProtocolHub",
  CrossChainProofHubV3: "CrossChainProofHubV3",

  // Privacy
  UniversalShieldedPool: "UniversalShieldedPool",
  CrossChainPrivacyHub: "CrossChainPrivacyHub",
  StealthAddressRegistry: "StealthAddressRegistry",
  ViewKeyRegistry: "ViewKeyRegistry",
  BatchAccumulator: "BatchAccumulator",
  DataAvailabilityOracle: "DataAvailabilityOracle",
  PrivacyZoneManager: "PrivacyZoneManager",

  // Primitives
  ZKBoundStateLocks: "ZKBoundStateLocks",
  ProofCarryingContainer: "ProofCarryingContainer",
  NullifierRegistryV3: "NullifierRegistryV3",

  // Bridge
  MultiBridgeRouter: "MultiBridgeRouter",
  SoulAtomicSwapV2: "SoulAtomicSwapV2",

  // Cross-chain adapters
  ArbitrumBridgeAdapter: "ArbitrumBridgeAdapter",
  OptimismBridgeAdapter: "OptimismBridgeAdapter",
  BaseBridgeAdapter: "BaseBridgeAdapter",
  ScrollBridgeAdapter: "ScrollBridgeAdapter",
  LineaBridgeAdapter: "LineaBridgeAdapter",
  zkSyncBridgeAdapter: "ZkSyncBridgeAdapter",
  PolygonZkEVMBridgeAdapter: "PolygonZkEVMBridgeAdapter",

  // Relayer
  DecentralizedRelayerRegistry: "DecentralizedRelayerRegistry",
  RelayerFeeMarket: "RelayerFeeMarket",
  MultiRelayerRouter: "MultiRelayerRouter",

  // Security
  BridgeWatchtower: "BridgeWatchtower",
  BridgeRateLimiter: "BridgeRateLimiter",
  ProtocolEmergencyCoordinator: "ProtocolEmergencyCoordinator",

  // Compliance
  SelectiveDisclosure: "SelectiveDisclosure",

  // Governance
  SoulGovernance: "SoulGovernance",

  // Verifiers
  VerifierRegistryV2: "VerifierRegistryV2",
};

function main() {
  // Ensure ABI output directory exists
  if (!fs.existsSync(ABI_DIR)) {
    fs.mkdirSync(ABI_DIR, { recursive: true });
  }

  // Check that Foundry `out/` directory exists
  if (!fs.existsSync(OUT_DIR)) {
    console.error(`ERROR: ${OUT_DIR} not found. Run 'forge build' first.`);
    process.exit(1);
  }

  let synced = 0;
  let skipped = 0;
  const errors: string[] = [];

  for (const [contractName, outputName] of Object.entries(CONTRACTS)) {
    const artifactPath = path.join(
      OUT_DIR,
      `${contractName}.sol`,
      `${contractName}.json`,
    );

    if (!fs.existsSync(artifactPath)) {
      console.warn(
        `  SKIP: ${contractName} — artifact not found at ${artifactPath}`,
      );
      skipped++;
      continue;
    }

    try {
      const raw = fs.readFileSync(artifactPath, "utf-8");
      const artifact = JSON.parse(raw);
      const abi = artifact.abi;

      if (!abi || !Array.isArray(abi)) {
        console.warn(`  SKIP: ${contractName} — no ABI in artifact`);
        skipped++;
        continue;
      }

      const abiJson = JSON.stringify(abi, null, 2);
      const tsContent = [
        `// Auto-generated by scripts/sync-abis.ts — DO NOT EDIT`,
        `// Source: out/${contractName}.sol/${contractName}.json`,
        `// Generated: ${new Date().toISOString()}`,
        ``,
        `export const ${outputName.replace(/[^a-zA-Z0-9_]/g, "_")}_ABI = ${abiJson} as const;`,
        ``,
      ].join("\n");

      const outPath = path.join(ABI_DIR, `${outputName}.ts`);
      fs.writeFileSync(outPath, tsContent, "utf-8");
      console.log(
        `  OK: ${contractName} → sdk/src/abis/${outputName}.ts (${abi.length} entries)`,
      );
      synced++;
    } catch (err: any) {
      errors.push(`${contractName}: ${err.message}`);
    }
  }

  // Write barrel export
  const indexLines = [
    `// Auto-generated by scripts/sync-abis.ts — DO NOT EDIT`,
    ``,
  ];
  for (const outputName of Object.values(CONTRACTS)) {
    indexLines.push(
      `export { ${outputName.replace(/[^a-zA-Z0-9_]/g, "_")}_ABI } from "./${outputName}";`,
    );
  }
  indexLines.push(``);
  fs.writeFileSync(
    path.join(ABI_DIR, "index.ts"),
    indexLines.join("\n"),
    "utf-8",
  );

  console.log(`\nABI sync complete: ${synced} synced, ${skipped} skipped`);
  if (errors.length > 0) {
    console.error(`Errors:`);
    errors.forEach((e) => console.error(`  - ${e}`));
    process.exit(1);
  }
}

main();
