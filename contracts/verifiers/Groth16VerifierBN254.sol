// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../interfaces/IProofVerifier.sol";

/**
 * @title Groth16VerifierBN254
 * @author Soul Protocol
 * @notice Production-ready Groth16 verifier for BN254 curve
 * @dev Uses EVM precompiles: bn256Add (0x06), bn256ScalarMul (0x07), bn256Pairing (0x08)
 *
 * This verifier is compatible with circuits generated by:
 * - Circom with snarkjs
 * - ZoKrates
 * - Any Groth16 prover using BN254 curve
 *
 * Proof format (256 bytes):
 * - π_A: G1 point (64 bytes) [x, y]
 * - π_B: G2 point (128 bytes) [x_im, x_re, y_im, y_re]
 * - π_C: G1 point (64 bytes) [x, y]
 */
contract Groth16VerifierBN254 is IProofVerifier {
    /*//////////////////////////////////////////////////////////////
                             CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice BN254 curve order (scalar field Fr)
    uint256 internal constant _FIELD_MODULUS =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;

    /// @notice BN254 base field Fq
    uint256 internal constant _Q_MODULUS =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @notice Proof size in bytes (256 = 64 + 128 + 64)
    uint256 internal constant _PROOF_SIZE = 256;

    /// @notice G1 point size (64 bytes = 2 * 32)
    uint256 internal constant _G1_SIZE = 64;

    /// @notice G2 point size (128 bytes = 4 * 32)
    uint256 internal constant _G2_SIZE = 128;

    /*//////////////////////////////////////////////////////////////
                         VERIFICATION KEY
    //////////////////////////////////////////////////////////////*/

    /// @notice Verification key - Alpha G1 point
    uint256[2] public vkAlpha;

    /// @notice Verification key - Beta G2 point [x_im, x_re, y_im, y_re]
    uint256[4] public vkBeta;

    /// @notice Verification key - Gamma G2 point
    uint256[4] public vkGamma;

    /// @notice Verification key - Delta G2 point
    uint256[4] public vkDelta;

    /// @notice Verification key - IC points (input commitments)
    uint256[2][] public vkIC;

    /// @notice Whether the verification key is set
    bool public initialized;

    /// @notice Contract owner
    address public owner;

    /*//////////////////////////////////////////////////////////////
                              ERRORS
    //////////////////////////////////////////////////////////////*/

    error NotOwner();
    error NotInitialized();
    error AlreadyInitialized();
    error InvalidProofSize(uint256 size);
    error InvalidPublicInputCount(uint256 provided, uint256 expected);
    error InvalidPublicInput(uint256 index, uint256 value);
    error PairingCheckFailed();
    error PrecompileFailed();
    error InvalidOwner();


    /*//////////////////////////////////////////////////////////////
                              EVENTS
    //////////////////////////////////////////////////////////////*/

    event VerificationKeySet(uint256 icLength);
    event ProofVerified(bytes32 indexed proofHash, bool result);
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /*//////////////////////////////////////////////////////////////
                            MODIFIERS
    //////////////////////////////////////////////////////////////*/

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    modifier whenInitialized() {
        if (!initialized) revert NotInitialized();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                           CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor() {
        owner = msg.sender;
    }

    /*//////////////////////////////////////////////////////////////
                    VERIFICATION KEY MANAGEMENT
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Set the verification key
     * @param alpha Alpha G1 point [x, y]
     * @param beta Beta G2 point [x_im, x_re, y_im, y_re]
     * @param gamma Gamma G2 point
     * @param delta Delta G2 point
     * @param ic Array of IC G1 points
     */
    function setVerificationKey(
        uint256[2] calldata alpha,
        uint256[4] calldata beta,
        uint256[4] calldata gamma,
        uint256[4] calldata delta,
        uint256[2][] calldata ic
    ) external onlyOwner {
        // M-7 Fix: Allow key rotation by owner (removed AlreadyInitialized check)
        
        vkAlpha = alpha;
        vkBeta = beta;
        vkGamma = gamma;
        vkDelta = delta;

        // Copy IC array with optimized loop
        delete vkIC;
        uint256 icLen = ic.length;
        for (uint256 i = 0; i < icLen; ) {
            vkIC.push(ic[i]);
            unchecked {
                ++i;
            }
        }

        initialized = true;

        emit VerificationKeySet(icLen);
    }

    /*//////////////////////////////////////////////////////////////
                      IPROOFVERIFIER INTERFACE
    //////////////////////////////////////////////////////////////*/

    /**
     * @inheritdoc IProofVerifier
     */
    function verify(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view override whenInitialized returns (bool) {
        if (proof.length != _PROOF_SIZE) {
            revert InvalidProofSize(proof.length);
        }

        uint256 expectedInputs = vkIC.length - 1;
        uint256 inputLen = publicInputs.length;
        if (inputLen != expectedInputs) {
            revert InvalidPublicInputCount(inputLen, expectedInputs);
        }

        // Validate public inputs are in the field with optimized loop
        for (uint256 i = 0; i < inputLen; ) {
            if (publicInputs[i] >= _FIELD_MODULUS) {
                revert InvalidPublicInput(i, publicInputs[i]);
            }
            unchecked {
                ++i;
            }
        }

        // Decode proof
        (
            uint256[2] memory piA,
            uint256[4] memory piB,
            uint256[2] memory piC
        ) = _decodeProof(proof);

        // Verify the pairing
        return _verifyPairing(piA, piB, piC, publicInputs);
    }

    /**
     * @inheritdoc IProofVerifier
     */
    function verifySingle(
        bytes calldata proof,
        uint256 publicInput
    ) external view override whenInitialized returns (bool) {
        uint256[] memory inputs = new uint256[](1);
        inputs[0] = publicInput;

        if (proof.length != _PROOF_SIZE) {
            revert InvalidProofSize(proof.length);
        }

        if (publicInput >= _FIELD_MODULUS) {
            revert InvalidPublicInput(0, publicInput);
        }

        (
            uint256[2] memory piA,
            uint256[4] memory piB,
            uint256[2] memory piC
        ) = _decodeProof(proof);

        return _verifyPairing(piA, piB, piC, inputs);
    }

    /**
     * @inheritdoc IProofVerifier
     */
    function getPublicInputCount() external view override returns (uint256) {
        return vkIC.length > 0 ? vkIC.length - 1 : 0;
    }

    /**
     * @inheritdoc IProofVerifier
     */
    function verifyProof(
        bytes calldata proof,
        bytes calldata publicInputs
    ) external view override returns (bool) {
        // Decode public inputs from bytes to uint256[]
        uint256[] memory inputs = abi.decode(publicInputs, (uint256[]));
        return this.verify(proof, inputs);
    }

    /**
     * @inheritdoc IProofVerifier
     */
    function isReady() external view override returns (bool) {
        return initialized;
    }

    /*//////////////////////////////////////////////////////////////
                       INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Decode proof bytes into components
     */
    function _decodeProof(
        bytes calldata proof
    )
        internal
        pure
        returns (
            uint256[2] memory piA,
            uint256[4] memory piB,
            uint256[2] memory piC
        )
    {
        // π_A: bytes 0-63
        piA[0] = uint256(bytes32(proof[0:32]));
        piA[1] = uint256(bytes32(proof[32:64]));

        // π_B: bytes 64-191 (G2 point)
        piB[0] = uint256(bytes32(proof[64:96]));
        piB[1] = uint256(bytes32(proof[96:128]));
        piB[2] = uint256(bytes32(proof[128:160]));
        piB[3] = uint256(bytes32(proof[160:192]));

        // π_C: bytes 192-255
        piC[0] = uint256(bytes32(proof[192:224]));
        piC[1] = uint256(bytes32(proof[224:256]));
    }

    /**
     * @notice Verify the Groth16 pairing equation
     * @dev e(A, B) = e(α, β) · e(∑ IC_i * input_i, γ) · e(C, δ)
     */
    function _verifyPairing(
        uint256[2] memory piA,
        uint256[4] memory piB,
        uint256[2] memory piC,
        uint256[] memory publicInputs
    ) internal view returns (bool) {
        // Compute linear combination: vk_x = IC[0] + Σ(IC[i+1] * input[i])
        uint256[2] memory vkX = vkIC[0];

        for (uint256 i = 0; i < publicInputs.length; i++) {
            // IC[i+1] * input[i]
            uint256[2] memory mulResult = _scalarMul(
                vkIC[i + 1],
                publicInputs[i]
            );
            // vk_x + mulResult
            vkX = _pointAdd(vkX, mulResult);
        }

        // Negate piA for the pairing check
        uint256[2] memory negA = _negate(piA);

        // Prepare pairing input (4 pairs for 768 bytes)
        // e(-A, B) * e(α, β) * e(vk_x, γ) * e(C, δ) = 1
        uint256[24] memory input;

        // Pair 1: -A, B
        input[0] = negA[0];
        input[1] = negA[1];
        input[2] = piB[0];
        input[3] = piB[1];
        input[4] = piB[2];
        input[5] = piB[3];

        // Pair 2: α, β
        input[6] = vkAlpha[0];
        input[7] = vkAlpha[1];
        input[8] = vkBeta[0];
        input[9] = vkBeta[1];
        input[10] = vkBeta[2];
        input[11] = vkBeta[3];

        // Pair 3: vk_x, γ
        input[12] = vkX[0];
        input[13] = vkX[1];
        input[14] = vkGamma[0];
        input[15] = vkGamma[1];
        input[16] = vkGamma[2];
        input[17] = vkGamma[3];

        // Pair 4: C, δ
        input[18] = piC[0];
        input[19] = piC[1];
        input[20] = vkDelta[0];
        input[21] = vkDelta[1];
        input[22] = vkDelta[2];
        input[23] = vkDelta[3];

        // Call pairing precompile
        uint256[1] memory result;
        bool success;

        assembly {
            success := staticcall(
                gas(),
                0x08, // bn256Pairing precompile
                input,
                768, // 24 * 32 bytes
                result,
                32
            )
        }

        if (!success) revert PrecompileFailed();

        return result[0] == 1;
    }

    /**
     * @notice Negate a G1 point (flip y coordinate)
     */
    function _negate(
        uint256[2] memory point
    ) internal pure returns (uint256[2] memory) {
        if (point[0] == 0 && point[1] == 0) {
            return point; // Point at infinity
        }
        return [point[0], _Q_MODULUS - (point[1] % _Q_MODULUS)];
    }

    /**
     * @notice Add two G1 points using precompile
     */
    function _pointAdd(
        uint256[2] memory p1,
        uint256[2] memory p2
    ) internal view returns (uint256[2] memory result) {
        uint256[4] memory input = [p1[0], p1[1], p2[0], p2[1]];

        assembly {
            let success := staticcall(gas(), 0x06, input, 128, result, 64)
            if iszero(success) {
                revert(0, 0)
            }
        }
    }

    /**
     * @notice Scalar multiply a G1 point using precompile
     */
    function _scalarMul(
        uint256[2] memory point,
        uint256 scalar
    ) internal view returns (uint256[2] memory result) {
        uint256[3] memory input = [point[0], point[1], scalar];

        assembly {
            let success := staticcall(gas(), 0x07, input, 96, result, 64)
            if iszero(success) {
                revert(0, 0)
            }
        }
    }

    /**
     * @notice Transfer ownership
     * @param newOwner New owner address
     */
    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) revert InvalidOwner();

        address oldOwner = owner;
        owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}
