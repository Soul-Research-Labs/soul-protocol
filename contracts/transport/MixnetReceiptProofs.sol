// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title MixnetReceiptProofs
 * @author Soul Protocol
 * @notice Verifiable delivery receipts for anonymous message routing through mixnets
 * @dev Enables proof of message delivery without revealing sender identity
 *
 * MIXNET ARCHITECTURE:
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │                        ANONYMOUS MESSAGE ROUTING                            │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │                                                                             │
 * │  Sender ──► Mix Node 1 ──► Mix Node 2 ──► Mix Node 3 ──► Recipient         │
 * │    │           │              │              │              │               │
 * │    │           │              │              │              │               │
 * │    ▼           ▼              ▼              ▼              ▼               │
 * │  [Onion    [Strip      [Strip       [Strip       [Delivery                 │
 * │   Encrypt]  Layer 1]    Layer 2]     Layer 3]     Receipt]                 │
 * │                                                                             │
 * │  Each node:                                                                 │
 * │  - Removes one encryption layer                                             │
 * │  - Shuffles with other messages (temporal mixing)                          │
 * │  - Forwards to next node                                                   │
 * │  - Generates hop receipt                                                   │
 * │                                                                             │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * RECEIPT PROOF GUARANTEE:
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │ The sender can prove:                                                       │
 * │   1. Message was delivered to recipient                                     │
 * │   2. Message traversed the specified mix path                              │
 * │   3. No tampering occurred during transit                                  │
 * │                                                                             │
 * │ WITHOUT revealing:                                                          │
 * │   - Sender identity                                                         │
 * │   - Message content                                                         │
 * │   - Timing correlation                                                      │
 * │   - Other messages in the same mix batch                                   │
 * └─────────────────────────────────────────────────────────────────────────────┘
 *
 * USE CASES:
 * - Anonymous whistleblowing with delivery confirmation
 * - Private voting with receipt verification
 * - Confidential transactions with settlement proof
 * - Cross-chain messaging with unlinkability
 */
contract MixnetReceiptProofs is AccessControl, ReentrancyGuard, Pausable {
    /*//////////////////////////////////////////////////////////////
                                 ROLES
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant MIXNET_ADMIN_ROLE = keccak256("MIXNET_ADMIN_ROLE");
    bytes32 public constant MIX_NODE_ROLE = keccak256("MIX_NODE_ROLE");
    bytes32 public constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
    bytes32 public constant SENDER_ROLE = keccak256("SENDER_ROLE");

    /*//////////////////////////////////////////////////////////////
                                 TYPES
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Mixnet message status
     */
    enum MessageStatus {
        Created,
        InTransit,
        Delivered,
        Failed,
        Expired,
        Challenged
    }

    /**
     * @notice Hop receipt - generated by each mix node
     */
    struct HopReceipt {
        bytes32 hopId;
        bytes32 messageTag; // Unlinkable tag for this hop
        bytes32 nodeId; // Mix node that processed this hop
        bytes32 inputCommitment; // Commitment to input (previous layer)
        bytes32 outputCommitment; // Commitment to output (next layer)
        bytes32 mixProof; // ZK proof of correct mixing
        bytes32 timingCommitment; // Commitment to processing time (prevents timing attacks)
        uint64 processedAt;
        bool valid;
    }

    /**
     * @notice Delivery receipt - final proof of delivery
     */
    struct DeliveryReceipt {
        bytes32 receiptId;
        bytes32 messageId; // Original message identifier (hidden from nodes)
        bytes32 senderCommitment; // Commitment to sender (only sender can open)
        bytes32 recipientCommitment; // Commitment to recipient
        bytes32 contentHash; // Hash of delivered content
        bytes32 pathCommitment; // Commitment to the mix path taken
        bytes32[] hopReceiptIds; // IDs of hop receipts (aggregated proof)
        bytes32 aggregateProof; // Aggregated ZK proof of all hops
        bytes32 deliveryProof; // Final delivery verification proof
        uint64 sentAt; // When message entered mixnet
        uint64 deliveredAt; // When delivered to recipient
        MessageStatus status;
        bool verified;
    }

    /**
     * @notice Mix batch - messages mixed together for unlinkability
     */
    struct MixBatch {
        bytes32 batchId;
        bytes32 nodeId; // Mix node processing this batch
        uint256 batchSize; // Number of messages in batch (padded)
        bytes32 inputsRoot; // Merkle root of input commitments
        bytes32 outputsRoot; // Merkle root of output commitments
        bytes32 shuffleProof; // ZK proof of valid shuffle
        uint64 processedAt;
        bool finalized;
    }

    /**
     * @notice Anonymous sender proof - proves sender without revealing identity
     */
    struct SenderProof {
        bytes32 proofId;
        bytes32 receiptId;
        bytes32 senderNullifier; // Unique nullifier (can't be used twice)
        bytes32 membershipProof; // Proof of membership in authorized senders
        bytes32 bindingCommitment; // Binds proof to specific receipt
        uint64 createdAt;
        bool verified;
    }

    /**
     * @notice Mix path - the route through the mixnet
     */
    struct MixPath {
        bytes32 pathId;
        bytes32[] nodeIds; // Ordered list of mix nodes
        uint256 hopCount;
        bytes32 pathCommitment; // Hidden commitment to full path
        uint64 createdAt;
        uint64 expiresAt;
        bool active;
    }

    /**
     * @notice Receipt challenge - dispute a receipt's validity
     */
    struct ReceiptChallenge {
        bytes32 challengeId;
        bytes32 receiptId;
        address challenger;
        bytes32 evidenceHash;
        ChallengeType challengeType;
        uint256 stake;
        uint64 createdAt;
        uint64 deadline;
        ChallengeStatus status;
    }

    enum ChallengeType {
        InvalidHop, // A hop receipt is invalid
        InvalidShuffle, // Shuffle proof is invalid
        TamperingDetected, // Message was modified
        PathDeviation, // Message didn't follow declared path
        TimingCorrelation, // Timing attack detected
        DoubleDelivery // Message delivered twice
    }

    enum ChallengeStatus {
        Pending,
        Accepted,
        Rejected,
        Resolved
    }

    /*//////////////////////////////////////////////////////////////
                                STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice Delivery receipts
    mapping(bytes32 => DeliveryReceipt) public receipts;
    uint256 public totalReceipts;

    /// @notice Hop receipts
    mapping(bytes32 => HopReceipt) public hopReceipts;

    /// @notice Mix batches
    mapping(bytes32 => MixBatch) public mixBatches;

    /// @notice Sender proofs
    mapping(bytes32 => SenderProof) public senderProofs;

    /// @notice Mix paths
    mapping(bytes32 => MixPath) public mixPaths;

    /// @notice Challenges
    mapping(bytes32 => ReceiptChallenge) public challenges;

    /// @notice Message tag to receipt mapping (for verification)
    mapping(bytes32 => bytes32) public tagToReceipt;

    /// @notice Used nullifiers (prevent double-spending of proofs)
    mapping(bytes32 => bool) public usedNullifiers;

    /// @notice Node to receipts mapping
    mapping(bytes32 => bytes32[]) public nodeReceipts;

    /// @notice Minimum mix batch size (for anonymity)
    uint256 public minBatchSize = 8;

    /// @notice Maximum mix path length
    uint256 public maxPathLength = 10;

    /// @notice Receipt validity period
    uint256 public receiptValidityPeriod = 7 days;

    /// @notice Challenge stake requirement
    uint256 public challengeStake = 0.05 ether;

    /// @notice Challenge period
    uint256 public challengePeriod = 24 hours;

    /// @notice Maximum batch size for array operations (gas limit protection)
    uint256 public constant MAX_BATCH_SIZE = 100;

    /// @notice Custom error for batch size exceeded
    error BatchSizeExceeded(uint256 provided, uint256 maximum);

    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    event MessageEntered(
        bytes32 indexed messageTag,
        bytes32 pathCommitment,
        uint256 hopCount
    );

    event HopProcessed(
        bytes32 indexed hopId,
        bytes32 indexed nodeId,
        bytes32 messageTag
    );

    event BatchProcessed(
        bytes32 indexed batchId,
        bytes32 indexed nodeId,
        uint256 batchSize
    );

    event DeliveryReceiptCreated(
        bytes32 indexed receiptId,
        bytes32 recipientCommitment,
        uint256 hopCount
    );

    event ReceiptVerified(bytes32 indexed receiptId, bool valid);

    event SenderProofSubmitted(
        bytes32 indexed proofId,
        bytes32 indexed receiptId
    );

    event ReceiptChallenged(
        bytes32 indexed receiptId,
        bytes32 indexed challengeId,
        ChallengeType challengeType
    );

    event ChallengeResolved(bytes32 indexed challengeId, bool challengerWon);

    /*//////////////////////////////////////////////////////////////
                              CUSTOM ERRORS
    //////////////////////////////////////////////////////////////*/

    error InvalidMessageTag(bytes32 tag);
    error InvalidHopReceipt(bytes32 hopId);
    error InvalidMixProof(bytes32 proofHash);
    error InvalidShuffleProof(bytes32 batchId);
    error InvalidDeliveryProof(bytes32 receiptId);
    error InvalidSenderProof(bytes32 proofId);
    error PathTooLong(uint256 length, uint256 maxLength);
    error PathTooShort(uint256 length);
    error BatchTooSmall(uint256 size, uint256 minSize);
    error NullifierAlreadyUsed(bytes32 nullifier);
    error ReceiptNotFound(bytes32 receiptId);
    error ReceiptExpired(bytes32 receiptId);
    error ReceiptAlreadyChallenged(bytes32 receiptId);
    error InsufficientChallengeStake();
    error ChallengeNotFound(bytes32 challengeId);
    error ChallengePeriodExpired();
    error NotMixNode();
    error PathExpired(bytes32 pathId);
    error HopSequenceInvalid();

    /*//////////////////////////////////////////////////////////////
                             CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MIXNET_ADMIN_ROLE, msg.sender);
    }

    /*//////////////////////////////////////////////////////////////
                        PATH MANAGEMENT
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Create a mix path for message routing
     * @param nodeIds Ordered array of mix node IDs
     * @param pathCommitment Hidden commitment to the full path
     * @param expiresAt Path expiration timestamp
     */
    function createPath(
        bytes32[] calldata nodeIds,
        bytes32 pathCommitment,
        uint64 expiresAt
    ) external whenNotPaused returns (bytes32 pathId) {
        if (nodeIds.length > maxPathLength) {
            revert PathTooLong(nodeIds.length, maxPathLength);
        }
        if (nodeIds.length < 2) {
            revert PathTooShort(nodeIds.length);
        }

        pathId = keccak256(
            abi.encodePacked(
                pathCommitment,
                nodeIds.length,
                block.timestamp,
                msg.sender
            )
        );

        mixPaths[pathId] = MixPath({
            pathId: pathId,
            nodeIds: nodeIds,
            hopCount: nodeIds.length,
            pathCommitment: pathCommitment,
            createdAt: uint64(block.timestamp),
            expiresAt: expiresAt,
            active: true
        });
    }

    /*//////////////////////////////////////////////////////////////
                        HOP PROCESSING
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Record a hop receipt from a mix node
     * @param messageTag Unlinkable message tag for this hop
     * @param inputCommitment Commitment to input (previous layer)
     * @param outputCommitment Commitment to output (next layer)
     * @param mixProof ZK proof of correct layer peeling
     * @param timingCommitment Commitment to processing timing
     */
    function recordHop(
        bytes32 messageTag,
        bytes32 inputCommitment,
        bytes32 outputCommitment,
        bytes32 mixProof,
        bytes32 timingCommitment
    ) external onlyRole(MIX_NODE_ROLE) whenNotPaused returns (bytes32 hopId) {
        // Generate hop ID
        hopId = keccak256(
            abi.encodePacked(messageTag, msg.sender, block.timestamp)
        );

        // Get node ID from sender
        bytes32 nodeId = keccak256(abi.encodePacked(msg.sender));

        hopReceipts[hopId] = HopReceipt({
            hopId: hopId,
            messageTag: messageTag,
            nodeId: nodeId,
            inputCommitment: inputCommitment,
            outputCommitment: outputCommitment,
            mixProof: mixProof,
            timingCommitment: timingCommitment,
            processedAt: uint64(block.timestamp),
            valid: true
        });

        nodeReceipts[nodeId].push(hopId);

        emit HopProcessed(hopId, nodeId, messageTag);
    }

    /**
     * @notice Record a mix batch processing
     * @param inputsRoot Merkle root of input commitments
     * @param outputsRoot Merkle root of output commitments
     * @param batchSize Number of messages in batch
     * @param shuffleProof ZK proof of valid shuffle
     */
    function recordBatch(
        bytes32 inputsRoot,
        bytes32 outputsRoot,
        uint256 batchSize,
        bytes32 shuffleProof
    ) external onlyRole(MIX_NODE_ROLE) whenNotPaused returns (bytes32 batchId) {
        if (batchSize < minBatchSize) {
            revert BatchTooSmall(batchSize, minBatchSize);
        }

        batchId = keccak256(
            abi.encodePacked(
                inputsRoot,
                outputsRoot,
                msg.sender,
                block.timestamp
            )
        );

        bytes32 nodeId = keccak256(abi.encodePacked(msg.sender));

        mixBatches[batchId] = MixBatch({
            batchId: batchId,
            nodeId: nodeId,
            batchSize: batchSize,
            inputsRoot: inputsRoot,
            outputsRoot: outputsRoot,
            shuffleProof: shuffleProof,
            processedAt: uint64(block.timestamp),
            finalized: true
        });

        emit BatchProcessed(batchId, nodeId, batchSize);
    }

    /*//////////////////////////////////////////////////////////////
                        DELIVERY RECEIPTS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Create a delivery receipt
     * @param messageId Original message identifier (hidden from nodes)
     * @param senderCommitment Commitment to sender identity
     * @param recipientCommitment Commitment to recipient
     * @param contentHash Hash of delivered content
     * @param pathCommitment Commitment to the mix path
     * @param hopReceiptIds Array of hop receipt IDs
     * @param aggregateProof Aggregated proof of all hops
     * @param deliveryProof Final delivery verification proof
     * @param sentAt When message entered mixnet
     */
    function createDeliveryReceipt(
        bytes32 messageId,
        bytes32 senderCommitment,
        bytes32 recipientCommitment,
        bytes32 contentHash,
        bytes32 pathCommitment,
        bytes32[] calldata hopReceiptIds,
        bytes32 aggregateProof,
        bytes32 deliveryProof,
        uint64 sentAt
    )
        external
        onlyRole(MIX_NODE_ROLE)
        whenNotPaused
        returns (bytes32 receiptId)
    {
        // Verify hop chain is valid
        if (!_verifyHopChain(hopReceiptIds)) {
            revert HopSequenceInvalid();
        }

        receiptId = keccak256(
            abi.encodePacked(
                messageId,
                recipientCommitment,
                contentHash,
                block.timestamp
            )
        );

        receipts[receiptId] = DeliveryReceipt({
            receiptId: receiptId,
            messageId: messageId,
            senderCommitment: senderCommitment,
            recipientCommitment: recipientCommitment,
            contentHash: contentHash,
            pathCommitment: pathCommitment,
            hopReceiptIds: hopReceiptIds,
            aggregateProof: aggregateProof,
            deliveryProof: deliveryProof,
            sentAt: sentAt,
            deliveredAt: uint64(block.timestamp),
            status: MessageStatus.Delivered,
            verified: false
        });

        // Map message tag to receipt for lookup
        if (hopReceiptIds.length > 0) {
            bytes32 finalTag = hopReceipts[
                hopReceiptIds[hopReceiptIds.length - 1]
            ].messageTag;
            tagToReceipt[finalTag] = receiptId;
        }

        totalReceipts++;

        emit DeliveryReceiptCreated(
            receiptId,
            recipientCommitment,
            hopReceiptIds.length
        );
    }

    /**
     * @notice Verify a delivery receipt
     * @param receiptId The receipt to verify
     */
    function verifyReceipt(
        bytes32 receiptId
    ) external onlyRole(VERIFIER_ROLE) nonReentrant returns (bool valid) {
        DeliveryReceipt storage receipt = receipts[receiptId];

        if (receipt.receiptId == bytes32(0)) {
            revert ReceiptNotFound(receiptId);
        }

        // Check expiry
        if (block.timestamp > receipt.deliveredAt + receiptValidityPeriod) {
            revert ReceiptExpired(receiptId);
        }

        // Verify all hop receipts
        for (uint256 i = 0; i < receipt.hopReceiptIds.length; i++) {
            HopReceipt storage hop = hopReceipts[receipt.hopReceiptIds[i]];
            if (!hop.valid) {
                receipt.status = MessageStatus.Failed;
                emit ReceiptVerified(receiptId, false);
                return false;
            }
        }

        // Verify aggregate proof (simplified - would call ZK verifier)
        valid = _verifyAggregateProof(
            receipt.aggregateProof,
            receipt.pathCommitment,
            receipt.hopReceiptIds
        );

        if (valid) {
            // Verify delivery proof
            valid = _verifyDeliveryProof(
                receipt.deliveryProof,
                receipt.recipientCommitment,
                receipt.contentHash
            );
        }

        receipt.verified = valid;

        emit ReceiptVerified(receiptId, valid);
    }

    /*//////////////////////////////////////////////////////////////
                        SENDER PROOFS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Submit a sender proof - proves sender without revealing identity
     * @param receiptId The delivery receipt
     * @param senderNullifier Unique nullifier (prevents double-use)
     * @param membershipProof Proof of membership in authorized senders
     * @param bindingCommitment Binds proof to specific receipt
     */
    function submitSenderProof(
        bytes32 receiptId,
        bytes32 senderNullifier,
        bytes32 membershipProof,
        bytes32 bindingCommitment
    ) external nonReentrant whenNotPaused returns (bytes32 proofId) {
        DeliveryReceipt storage receipt = receipts[receiptId];

        if (receipt.receiptId == bytes32(0)) {
            revert ReceiptNotFound(receiptId);
        }

        if (usedNullifiers[senderNullifier]) {
            revert NullifierAlreadyUsed(senderNullifier);
        }

        // Verify the sender proof (simplified - would call ZK verifier)
        if (
            !_verifySenderProof(
                receipt.senderCommitment,
                senderNullifier,
                membershipProof,
                bindingCommitment
            )
        ) {
            revert InvalidSenderProof(bytes32(0));
        }

        proofId = keccak256(
            abi.encodePacked(receiptId, senderNullifier, block.timestamp)
        );

        senderProofs[proofId] = SenderProof({
            proofId: proofId,
            receiptId: receiptId,
            senderNullifier: senderNullifier,
            membershipProof: membershipProof,
            bindingCommitment: bindingCommitment,
            createdAt: uint64(block.timestamp),
            verified: true
        });

        // Mark nullifier as used
        usedNullifiers[senderNullifier] = true;

        emit SenderProofSubmitted(proofId, receiptId);
    }

    /**
     * @notice Verify a sender proof
     * @param proofId The sender proof to verify
     */
    function verifySenderProof(
        bytes32 proofId
    ) external view returns (bool valid, bytes32 receiptId) {
        SenderProof storage proof = senderProofs[proofId];
        return (proof.verified, proof.receiptId);
    }

    /*//////////////////////////////////////////////////////////////
                        CHALLENGE MECHANISM
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Challenge a receipt's validity
     * @param receiptId The receipt to challenge
     * @param evidenceHash Hash of evidence
     * @param challengeType Type of challenge
     */
    function challengeReceipt(
        bytes32 receiptId,
        bytes32 evidenceHash,
        ChallengeType challengeType
    )
        external
        payable
        nonReentrant
        whenNotPaused
        returns (bytes32 challengeId)
    {
        if (msg.value < challengeStake) {
            revert InsufficientChallengeStake();
        }

        DeliveryReceipt storage receipt = receipts[receiptId];

        if (receipt.receiptId == bytes32(0)) {
            revert ReceiptNotFound(receiptId);
        }

        if (receipt.status == MessageStatus.Challenged) {
            revert ReceiptAlreadyChallenged(receiptId);
        }

        challengeId = keccak256(
            abi.encodePacked(receiptId, msg.sender, block.timestamp)
        );

        challenges[challengeId] = ReceiptChallenge({
            challengeId: challengeId,
            receiptId: receiptId,
            challenger: msg.sender,
            evidenceHash: evidenceHash,
            challengeType: challengeType,
            stake: msg.value,
            createdAt: uint64(block.timestamp),
            deadline: uint64(block.timestamp + challengePeriod),
            status: ChallengeStatus.Pending
        });

        receipt.status = MessageStatus.Challenged;

        emit ReceiptChallenged(receiptId, challengeId, challengeType);
    }

    /**
     * @notice Resolve a challenge
     * @param challengeId The challenge to resolve
     * @param challengerWins Whether the challenger's claim is valid
     */
    function resolveChallenge(
        bytes32 challengeId,
        bool challengerWins
    ) external onlyRole(MIXNET_ADMIN_ROLE) {
        ReceiptChallenge storage challenge = challenges[challengeId];

        if (challenge.challengeId == bytes32(0)) {
            revert ChallengeNotFound(challengeId);
        }

        DeliveryReceipt storage receipt = receipts[challenge.receiptId];

        if (challengerWins) {
            challenge.status = ChallengeStatus.Accepted;
            receipt.status = MessageStatus.Failed;
            receipt.verified = false;

            // Return stake + reward to challenger (using call instead of transfer for gas compatibility)
            (bool success, ) = payable(challenge.challenger).call{
                value: challenge.stake
            }("");
            require(success, "Stake return failed");
        } else {
            challenge.status = ChallengeStatus.Rejected;
            receipt.status = MessageStatus.Delivered;

            // Stake is forfeited (could go to protocol treasury)
        }

        emit ChallengeResolved(challengeId, challengerWins);
    }

    /*//////////////////////////////////////////////////////////////
                        ANONYMOUS QUERIES
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Check if a message was delivered (by tag, not ID)
     * @param messageTag The unlinkable message tag
     */
    function wasDelivered(bytes32 messageTag) external view returns (bool) {
        bytes32 receiptId = tagToReceipt[messageTag];
        if (receiptId == bytes32(0)) return false;

        DeliveryReceipt storage receipt = receipts[receiptId];
        return receipt.status == MessageStatus.Delivered && receipt.verified;
    }

    /**
     * @notice Get receipt by message tag (preserves unlinkability)
     * @param messageTag The unlinkable message tag
     */
    function getReceiptByTag(
        bytes32 messageTag
    )
        external
        view
        returns (bytes32 receiptId, bool verified, uint64 deliveredAt)
    {
        receiptId = tagToReceipt[messageTag];
        if (receiptId != bytes32(0)) {
            DeliveryReceipt storage receipt = receipts[receiptId];
            verified = receipt.verified;
            deliveredAt = receipt.deliveredAt;
        }
    }

    /**
     * @notice Verify a path was followed without revealing path details
     * @param receiptId The delivery receipt
     * @param pathProof ZK proof that path matches commitment
     */
    function verifyPathFollowed(
        bytes32 receiptId,
        bytes32 pathProof
    ) external view returns (bool) {
        DeliveryReceipt storage receipt = receipts[receiptId];

        if (receipt.receiptId == bytes32(0)) return false;

        // Verify path proof against path commitment (simplified)
        return pathProof != bytes32(0) && receipt.pathCommitment != bytes32(0);
    }

    /*//////////////////////////////////////////////////////////////
                        VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Get delivery receipt
     */
    function getReceipt(
        bytes32 receiptId
    ) external view returns (DeliveryReceipt memory) {
        return receipts[receiptId];
    }

    /**
     * @notice Get hop receipt
     */
    function getHopReceipt(
        bytes32 hopId
    ) external view returns (HopReceipt memory) {
        return hopReceipts[hopId];
    }

    /**
     * @notice Get mix batch
     */
    function getMixBatch(
        bytes32 batchId
    ) external view returns (MixBatch memory) {
        return mixBatches[batchId];
    }

    /**
     * @notice Get sender proof
     */
    function getSenderProof(
        bytes32 proofId
    ) external view returns (SenderProof memory) {
        return senderProofs[proofId];
    }

    /**
     * @notice Get mix path
     */
    function getMixPath(bytes32 pathId) external view returns (MixPath memory) {
        return mixPaths[pathId];
    }

    /**
     * @notice Get challenge details
     */
    function getChallenge(
        bytes32 challengeId
    ) external view returns (ReceiptChallenge memory) {
        return challenges[challengeId];
    }

    /**
     * @notice Check if nullifier is used
     */
    function isNullifierUsed(bytes32 nullifier) external view returns (bool) {
        return usedNullifiers[nullifier];
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Verify hop chain is sequential and valid
     */
    function _verifyHopChain(
        bytes32[] calldata hopIds
    ) internal view returns (bool) {
        if (hopIds.length == 0) return false;
        if (hopIds.length > MAX_BATCH_SIZE)
            revert BatchSizeExceeded(hopIds.length, MAX_BATCH_SIZE);

        for (uint256 i = 0; i < hopIds.length; i++) {
            HopReceipt storage hop = hopReceipts[hopIds[i]];
            if (!hop.valid || hop.hopId == bytes32(0)) {
                return false;
            }

            // Verify chain linkage: output of hop i should match input of hop i+1
            if (i < hopIds.length - 1) {
                HopReceipt storage nextHop = hopReceipts[hopIds[i + 1]];
                // In production: verify outputCommitment[i] relates to inputCommitment[i+1]
                // This is simplified for the contract
                if (nextHop.hopId == bytes32(0)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * @notice Verify aggregate proof of all hops
     */
    function _verifyAggregateProof(
        bytes32 aggregateProof,
        bytes32 pathCommitment,
        bytes32[] storage hopIds
    ) internal view returns (bool) {
        // In production: verify ZK proof that aggregates all hop proofs
        // For now: basic validation
        return
            aggregateProof != bytes32(0) &&
            pathCommitment != bytes32(0) &&
            hopIds.length > 0;
    }

    /**
     * @notice Verify delivery proof
     */
    function _verifyDeliveryProof(
        bytes32 deliveryProof,
        bytes32 recipientCommitment,
        bytes32 contentHash
    ) internal pure returns (bool) {
        // In production: verify ZK proof of correct delivery
        return
            deliveryProof != bytes32(0) &&
            recipientCommitment != bytes32(0) &&
            contentHash != bytes32(0);
    }

    /**
     * @notice Verify sender proof
     */
    function _verifySenderProof(
        bytes32 senderCommitment,
        bytes32 senderNullifier,
        bytes32 membershipProof,
        bytes32 bindingCommitment
    ) internal pure returns (bool) {
        // In production: verify ZK proof that:
        // 1. Sender knows opening of senderCommitment
        // 2. Sender is member of authorized set (membershipProof)
        // 3. Proof is bound to specific receipt (bindingCommitment)
        // 4. Nullifier is correctly derived (prevents reuse)
        return
            senderCommitment != bytes32(0) &&
            senderNullifier != bytes32(0) &&
            membershipProof != bytes32(0) &&
            bindingCommitment != bytes32(0);
    }

    /*//////////////////////////////////////////////////////////////
                            ADMIN FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Update minimum batch size
     */
    function setMinBatchSize(
        uint256 size
    ) external onlyRole(MIXNET_ADMIN_ROLE) {
        require(size >= 2, "Batch size too small");
        minBatchSize = size;
    }

    /**
     * @notice Update maximum path length
     */
    function setMaxPathLength(
        uint256 length
    ) external onlyRole(MIXNET_ADMIN_ROLE) {
        require(length >= 2, "Path too short");
        maxPathLength = length;
    }

    /**
     * @notice Update receipt validity period
     */
    function setReceiptValidityPeriod(
        uint256 period
    ) external onlyRole(MIXNET_ADMIN_ROLE) {
        receiptValidityPeriod = period;
    }

    /**
     * @notice Update challenge stake
     */
    function setChallengeStake(
        uint256 stake
    ) external onlyRole(MIXNET_ADMIN_ROLE) {
        challengeStake = stake;
    }

    /**
     * @notice Pause the contract
     */
    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    /**
     * @notice Unpause the contract
     */
    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }
}
